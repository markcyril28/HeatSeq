# Gene Expression Analysis (GEA) Pipeline: Method Comparison

This document details the different approaches implemented in the Gene Expression Analysis (GEA) pipeline, from initial read processing to post-quantification analysis, including preparation for DESeq2 and heatmap generation.

## Overview of Methods

The GEA pipeline includes five distinct methods for quantifying gene expression from RNA-seq data. These methods vary primarily in their approach to alignment and quantification, catering to different scenarios (e.g., presence or absence of a reference genome/transcriptome).

### Method 1: HISAT2 Reference Guided

*   **Core Idea:** This method leverages a known reference genome and gene annotations (GTF file) to accurately align RNA-seq reads and then assemble and quantify transcripts.
*   **Key Steps:**
    1.  **Index Building:** HISAT2 index is built from the reference genome, incorporating splice site and exon information extracted from the GTF file.
    2.  **Alignment:** Trimmed RNA-seq reads are aligned to the indexed reference genome using HISAT2.
    3.  **Transcript Assembly & Quantification:** StringTie uses the aligned reads (BAM files) and the reference GTF to assemble transcripts and quantify gene/transcript abundances (FPKM, TPM, coverage, num_reads).
*   **Primary Tools:** `HISAT2`, `StringTie`
*   **Output:** Aligned BAM files, StringTie-assembled GTF files, `gene_abundances.tsv` files.

### Method 2: HISAT2 De Novo

*   **Core Idea:** This method is designed for scenarios where a high-quality reference genome or comprehensive gene annotation is unavailable. It aligns reads to a *de novo* assembled transcriptome (provided as a FASTA file).
*   **Key Steps:**
    1.  **Index Building:** HISAT2 index is built directly from a *de novo* assembled transcriptome FASTA file.
    2.  **Alignment:** Trimmed RNA-seq reads are aligned to this *de novo* transcriptome index using HISAT2.
    3.  **Transcript Assembly & Quantification:** StringTie uses the aligned reads (BAM files) to assemble transcripts and quantify gene/transcript abundances.
*   **Primary Tools:** `HISAT2`, `StringTie`
*   **Output:** Aligned BAM files, StringTie-assembled GTF files, `gene_abundances.tsv` files.

### Method 3: Trinity De Novo

*   **Core Idea:** This method performs a full *de novo* transcriptome assembly directly from the RNA-seq reads using Trinity, and then quantifies expression against this newly assembled transcriptome.
*   **Key Steps:**
    1.  **De Novo Assembly:** Trinity takes the trimmed RNA-seq reads and assembles them into a comprehensive transcriptome (Trinity.fasta).
    2.  **Alignment & Quantification (Trinity's Workflow):** Trinity's `align_and_estimate_abundance.pl` script aligns reads back to the assembled transcriptome (using tools like Bowtie2) and quantifies expression (using RSEM).
    3.  **StringTie Quantification (for DESeq2 compatibility):** StringTie is then used with the aligned reads (BAMs generated by Trinity's workflow) and the Trinity.fasta (treated as a reference GTF for structure) to produce gene abundance files in a format suitable for downstream DESeq2 analysis.
*   **Primary Tools:** `Trinity`, `Bowtie2` (via Trinity), `RSEM` (via Trinity), `StringTie`
*   **Output:** `Trinity.fasta` (assembled transcriptome), RSEM quantification results, StringTie `gene_abundances.tsv` files.

### Method 4: Salmon SAF Quantification

*   **Core Idea:** This method focuses on fast and accurate quantification of transcript abundance using Salmon's quasi-mapping approach. It is particularly efficient and often includes decoy-aware indexing to handle reads that map to repetitive regions of the genome.
*   **Key Steps:**
    1.  **Index Building:** Salmon builds a decoy-aware index from a reference transcriptome (FASTA) and a reference genome (FASTA, for decoys).
    2.  **Quasi-mapping & Quantification:** Trimmed RNA-seq reads are quasi-mapped to the Salmon index, and transcript-level abundances are estimated.
*   **Primary Tools:** `Salmon`
*   **Input:** Trimmed FASTQ reads, Reference Transcriptome (FASTA), Reference Genome (FASTA for decoys).
*   **Output:** `quant.sf` files (transcript-level quantification), which are then aggregated to gene-level count matrices.

### Method 5: Bowtie2 + RSEM Quantification

*   **Core Idea:** This method uses a traditional alignment-based approach for quantification. Reads are aligned to a reference transcriptome, and then RSEM is used to estimate gene and isoform expression levels.
*   **Key Steps:**
    1.  **Reference Preparation:** RSEM prepares a reference from the transcriptome FASTA file, which includes building a Bowtie2 index.
    2.  **Alignment & Quantification:** Trimmed RNA-seq reads are aligned to the transcriptome using Bowtie2 (managed by RSEM), and RSEM then quantifies gene and isoform expression.
*   **Primary Tools:** `Bowtie2` (via RSEM), `RSEM`
*   **Input:** Trimmed FASTQ reads, Reference Transcriptome (FASTA).
*   **Output:** RSEM results files (e.g., `.genes.results`, `.isoforms.results`) containing gene and isoform expression estimates.

## Post-Processing Steps

The post-processing phase transforms the raw quantification outputs from each method into actionable biological insights. This typically involves preparing data for differential expression analysis, performing the analysis itself, and visualizing the results.

### 1. StringTie to DESeq2 Preparation (for Methods 1, 2, and 3)

For methods that utilize StringTie (HISAT2 Reference Guided, HISAT2 De Novo, and Trinity De Novo), the initial output consists of `gene_abundances.tsv` files for each sample. A dedicated R script is employed to consolidate these files into a format suitable for DESeq2, a widely used R package for differential gene expression analysis.

*   **Input:** Individual `gene_abundances.tsv` files generated by StringTie for each sample.
*   **Key Steps:**
    1.  **File Collection:** The R script systematically identifies and collects all `gene_abundances.tsv` files corresponding to a specific FASTA tag and SRR ID.
    2.  **Count Extraction:** For each file, the `gene_id` and a column representing raw counts are extracted. The preferred column for raw counts is `num_reads`. If `num_reads` is not available, `FPKM` (Fragments Per Kilobase of transcript per Million mapped reads) values are used as a proxy and rounded to the nearest integer, as DESeq2 requires integer count data. Users are advised to consider alternative tools like `featureCounts` for direct raw count extraction if precise integer counts are critical and `num_reads` is absent.
    3.  **Matrix Merging:** The extracted gene counts from all samples are merged into a single, comprehensive gene-by-sample count matrix. This matrix has gene identifiers as row names and sample identifiers as column names. Genes not detected in all samples are assigned a count of zero for the missing samples.
    4.  **Sample Information Table (`colData`): A crucial `sample_info.tsv` file is generated. This table contains metadata for each sample, such as SRR ID and experimental conditions (e.g., "treatment", "control", "time_point"). This metadata is essential for DESeq2 to define the experimental design and perform statistical comparisons. Users are expected to review and customize the `condition` column based on their specific experimental setup.
*   **Output:**
    *   `gene_count_matrix.tsv`: A tab-separated file containing integer gene counts, with genes in rows and samples in columns.
    *   `sample_info.tsv`: A tab-separated file detailing sample metadata, including experimental conditions.

For Methods 4 (Salmon) and 5 (Bowtie2 + RSEM), the quantification tools directly produce gene-level count data (or can be aggregated to gene-level). These outputs are then similarly processed into a count matrix and paired with a sample information table, mirroring the structure required for DESeq2.

### 2. DESeq2 Analysis (in R)

DESeq2 is a powerful R package designed for differential expression analysis of RNA-seq data. It takes the prepared count matrix and sample information as input to identify genes that are significantly differentially expressed between different experimental conditions.

*   **Input:**
    *   Gene count matrix (e.g., `gene_count_matrix.tsv`).
    *   Sample information table (e.g., `sample_info.tsv`).
*   **Key Steps:**
    1.  **Data Import and Object Creation:** The count matrix and sample information are loaded into R, and a `DESeqDataSet` object is constructed, which is the primary data structure for DESeq2.
    2.  **Dispersion Estimation:** It estimates the gene-wise dispersion, which models the variance in gene expression across replicates. This is crucial for accurate statistical testing, especially with low replicate numbers.
    3.  **Differential Expression Testing:** Statistical tests (e.g., Wald test) are applied to identify genes with significant changes in expression between specified experimental groups.
*   **Output:**
    *   Results tables containing log2 fold changes, p-values, and adjusted p-values (FDR) for each gene, indicating their differential expression status.
    *   Normalized count data (e.g., `counts(dds, normalized=TRUE)`) for visualization and further analysis.

### 3. Heatmap Generation

Heatmaps are a crucial visualization tool in gene expression analysis, providing a graphical representation of gene expression patterns across multiple samples. They help in identifying clusters of co-expressed genes and groups of samples with similar expression profiles.

*   **Input:** Normalized gene expression matrices (e.g., from DESeq2, or directly from StringTie/Salmon/RSEM outputs after appropriate normalization).
*   **Key Steps:**
    1.  **Clustering:** Hierarchical clustering is typically applied to both genes and samples based on their expression similarity. This groups together genes with similar expression patterns and samples with similar overall profiles, often visualized as dendrograms alongside the heatmap.
    2.  **Visualization:** R packages such as `ComplexHeatmap`, `circlize`, and `RColorBrewer` are used to generate high-quality heatmaps. These heatmaps display:
        *   **Color Intensity:** Represents the expression level of a gene in a given sample, with a defined color scale (e.g., a gradient from low to high expression).
        *   **Dendrograms:** Illustrate the hierarchical clustering of genes and samples.
        *   **Annotations:** Additional information (e.g., sample conditions, gene functional categories, clinical data) can be added as annotations to the heatmap, providing further context.
*   **Output:**
    *   High-resolution PNG image files of the generated heatmaps.
    *   Corresponding TSV files of the normalized matrices used to generate the heatmaps, allowing for further programmatic analysis.

### 4. Normalization Schemes: Formulas and Procedures

Normalization is a critical step in RNA-seq data analysis, aiming to remove non-biological sources of variation (e.g., sequencing depth, library composition, gene length) to enable accurate comparison of gene expression levels across samples and genes. Below are common normalization schemes and their underlying principles.

#### a. DESeq2 Size Factor Normalization

*   **Purpose:** To account for differences in sequencing depth and RNA composition between samples, ensuring that observed count differences are due to true biological variation.
*   **Procedure:**
    1.  For each gene, calculate the geometric mean across all samples.
    2.  For each sample, calculate the ratio of its counts to the geometric mean for each gene. This creates a vector of ratios for each sample.
    3.  The size factor for a sample is the median of these ratios. This median-of-ratios approach is robust to outliers (e.g., a few highly expressed genes).
*   **Formula:**
    Let $K_{ij}$ be the raw count for gene $i$ in sample $j$.
    Let $GM_i = (\prod_{j=1}^{m} K_{ij})^{1/m}$ be the geometric mean of counts for gene $i$ across $m$ samples.
    The size factor for sample $j$ is $s_j = \text{median}_i \left( \frac{K_{ij}}{GM_i} \right)$.
    The normalized count for gene $i$ in sample $j$ is $K'_{ij} = \frac{K_{ij}}{s_j}$.
*   **Application:** Primarily used within the DESeq2 package for differential expression analysis. The normalized counts can also be used for visualization.

#### b. Raw Counts (Log-transformed)

*   **Purpose:** To stabilize variance and reduce the impact of extremely high counts, making the data more suitable for visualization and statistical methods that assume normality.
*   **Procedure:** Add a small pseudocount (typically 1) to raw counts to avoid taking the logarithm of zero, then apply a base-2 logarithm.
*   **Formula:** $Log_2(Counts + 1)$
*   **Application:** Commonly used for heatmaps and other visualizations where the magnitude of fold changes is important.

#### c. CPM (Counts Per Million)

*   **Purpose:** To normalize for differences in sequencing depth (library size) between samples, allowing for comparison of gene expression across samples.
*   **Procedure:** Divide the raw count for a gene by the total number of mapped reads in that sample (in millions).
*   **Formula:** $CPM_{ij} = \frac{K_{ij}}{\text{Total Reads}_j / 10^6}$
    Often followed by log2 transformation: $Log_2(CPM_{ij} + 1)$
*   **Application:** Useful for comparing relative gene expression levels across samples, especially for visualization and exploratory data analysis.

#### d. TPM (Transcripts Per Million)

*   **Purpose:** To normalize for both gene length and sequencing depth, making expression values comparable across samples and genes.
*   **Procedure:**
    1.  Divide the raw count for each gene by its length in kilobases.
    2.  Sum these length-normalized counts for all genes in the sample.
    3.  Divide the length-normalized count for each gene by the total sum (from step 2), and multiply by one million.
*   **Formula:**
    Let $K_{ij}$ be the raw count for gene $i$ in sample $j$.
    Let $L_i$ be the length of gene $i$ in kilobases.
    $RPK_{ij} = \frac{K_{ij}}{L_i}$
    $TPM_{ij} = \frac{RPK_{ij}}{\sum_{i=1}^{n} RPK_{ij}} \times 10^6$
    Often followed by log2 transformation: $Log_2(TPM_{ij} + 1)$
*   **Application:** Ideal for comparing gene expression levels both within and between samples, as it accounts for both library size and gene length bias.

#### e. FPKM (Fragments Per Kilobase of transcript per Million mapped reads)

*   **Purpose:** To normalize for gene length and sequencing depth. It was widely used but has largely been superseded by TPM due to better comparability across samples.
*   **Procedure:** Divide the raw count for a gene by its length in kilobases and by the total number of mapped reads in the sample (in millions).
*   **Formula:** $FPKM_{ij} = \frac{K_{ij}}{L_i \times (\text{Total Reads}_j / 10^6)}$
    Often followed by log2 transformation: $Log_2(FPKM_{ij} + 1)$
*   **Application:** Primarily for comparing expression within a single sample or for comparing expression of the *same gene* across different samples. Less suitable for comparing expression of *different genes* between samples.

#### f. Z-score (Standardization)

*   **Purpose:** To standardize expression values for each gene, highlighting relative changes and making the distribution of expression values centered around zero with a standard deviation of one. This is useful for visualizing patterns and clustering.
*   **Procedure:** For each gene, subtract the mean expression of that gene across all samples and then divide by the standard deviation of that gene's expression across all samples.
*   **Formula:** $Z_{ij} = \frac{X_{ij} - \mu_i}{\sigma_i}$
    Where $X_{ij}$ is the (already normalized, e.g., log-transformed CPM/TPM) expression value for gene $i$ in sample $j$, $\mu_i$ is the mean expression of gene $i$ across all samples, and $\sigma_i$ is the standard deviation of gene $i$ across all samples.
*   **Application:** Excellent for heatmaps and clustering, as it emphasizes relative expression changes and patterns, making genes with vastly different absolute expression levels comparable.

#### g. VST (Variance Stabilizing Transformation) / rlog (Regularized Log Transformation)

*   **Purpose:** These are DESeq2-specific transformations designed to stabilize the variance across the range of mean expression values. For RNA-seq data, variance typically increases with the mean. VST and rlog transform the data such that the variance becomes approximately independent of the mean, which is beneficial for downstream analyses like clustering and PCA.
*   **Procedure:** Both VST and rlog are implemented within the DESeq2 package. They involve fitting a dispersion-mean relationship and then transforming the raw counts based on this relationship. `rlog` is generally preferred for smaller datasets (e.g., fewer than 30 samples) or when there are large differences in library sizes, as it shrinks the log fold changes for genes with low counts more aggressively.
*   **Formula:** Complex, implemented internally by DESeq2, but conceptually aims to achieve $f(K_{ij}) \approx \log_2(K_{ij} + \text{constant})$ where the constant depends on the dispersion.
*   **Application:** Highly recommended for exploratory data analysis, clustering, PCA, and heatmaps when working with DESeq2, as they produce data that is homoscedastic (variance-stabilized).

## Summary Comparison Table

| Feature / Method        | Method 1: HISAT2 Ref Guided | Method 2: HISAT2 De Novo | Method 3: Trinity De Novo | Method 4: Salmon SAF Quantification | Method 5: Bowtie2 + RSEM Quantification |
| :---------------------- | :-------------------------- | :----------------------- | :------------------------ | :---------------------------------- | :-------------------------------------- |
| **Reference Required**  | Reference Genome + GTF      | De Novo Transcriptome (FASTA) | None (builds from reads)  | Reference Transcriptome + Genome (for decoys) | Reference Transcriptome (FASTA)         |
| **Alignment Tool**      | HISAT2                      | HISAT2                   | Bowtie2 (via Trinity)     | Salmon (quasi-mapping)              | Bowtie2 (via RSEM)                      |
| **Assembly Tool**       | StringTie                   | StringTie                | Trinity                   | N/A                                 | N/A                                     |
| **Quantification Tool** | StringTie                   | StringTie                | RSEM (via Trinity), StringTie | Salmon                              | RSEM                                    |
| **Output Type**         | Gene/Transcript Abundances (TSV, GTF) | Gene/Transcript Abundances (TSV, GTF) | Gene/Transcript Abundances (TSV, Trinity.fasta) | Transcript/Gene Counts (quant.sf)   | Gene/Isoform Counts (results files)     |
| **DESeq2 Input Prep**   | StringTie `gene_abundances.tsv` | StringTie `gene_abundances.tsv` | StringTie `gene_abundances.tsv` | Salmon `quant.sf` (aggregated)      | RSEM `.genes.results`                   |
| **Use Case**            | Well-annotated genomes      | No reference genome, but existing transcriptome | No reference genome/transcriptome | Fast, accurate transcript quantification | Accurate gene/isoform quantification    |
